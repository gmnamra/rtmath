// Doing the testing of the layer generation functions

		using namespace rtmath;
		using namespace std;

		double alb = 0.1;
		double tau = 1.0;
		double mu = 1.0, mun = 0.0, phi = 0.3, phin = 0.1;
		double x = 1.0;
		std::complex<double> m;
		m.real(1.33);
		m.imag(0.001);
		mapid mid(mu,mun,phi,phin);	

		// Use the rayleigh-scattering case, for starters
		// Need a layer with a phasefunction matrixop
		rayleigh::rayleighPhaseFunc ray;
		double Pnn[4][4];
		ray.calc(mu,m,x,Pnn);
		// Now, to convert Pnn to a matrixop, pf
		matrixop pf(2,4,4);
		pf.fromDoubleArray(*Pnn);
		shared_ptr<matrixop> Pm(new matrixop(pf));

		shared_ptr<daInitLayer> iLa( new daInitLayer(Pm,alb,tau,rtselec::R) );
		// Special cast is needed to keep shared_ptr happy. Unfortunate.
		// It also fixes the double free issue with daInitLayer cacheing, I think
		shared_ptr<damatrix> iLaBase = static_pointer_cast<damatrix>(iLa); 
		shared_ptr<matrixop> iLaeval = iLaBase->eval(mid);
		cout << "iLa\n";
		iLaeval->print();
		iLaeval = iLaBase->eval(mid);
		cout << "iLa\n";
		iLaeval->print();

		shared_ptr<damatrix> iLaDoubled = damatrix::op(iLaBase,iLaBase,MULT);
		shared_ptr<matrixop> iLaDoubledeval = iLaDoubled->eval(mid);
		cout << "iLaDoubled\n";
		iLaDoubledeval->print();
		iLaDoubledeval = iLaDoubled->eval(mid);
		cout << "iLaDoubled\n";
		iLaDoubledeval->print();